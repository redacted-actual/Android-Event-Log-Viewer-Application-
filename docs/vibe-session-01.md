Generate code for an Android OS event log viewer application.

This is a complex request because, for security reasons, modern Android versions (Android 4.1+) restrict third-party apps from reading system logs generated by other applications or the system itself.
To make this application work on a real device, you cannot simply request permission at runtime. You must grant the permission manually via ADB (Android Debug Bridge) after installing the app.
Below is a complete, modern Android project using Kotlin and Jetpack Compose that implements a functional Log Viewer.
Prerequisites
Android Studio (Koala or later recommended).
Min SDK: 24 (recommended).
Developer Options enabled on your device.
1. AndroidManifest.xml
You must declare the READ_LOGS permission. Even though it's a "signature" level permission, declaring it allows us to grant it via ADB later.

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.READ_LOGS"
        tools:ignore="ProtectedPermissions" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="LogViewer"
        android:theme="@style/Theme.LogViewer">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.LogViewer">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

2. The Data Model (LogEntry.kt)
We need a structure to hold parsed log data.

package com.example.logviewer

import androidx.compose.ui.graphics.Color

data class LogEntry(
    val id: Int,
    val timestamp: String,
    val level: String,
    val tag: String,
    val message: String
) {
    // Helper to color-code log levels
    fun getLevelColor(): Color {
        return when (level) {
            "E" -> Color.Red         // Error
            "W" -> Color(0xFFFFA500) // Warning (Orange)
            "I" -> Color.Green       // Info
            "D" -> Color.Blue        // Debug
            "V" -> Color.Gray        // Verbose
            else -> Color.White
        }
    }
}


3. The Log Reader Utility (LogReader.kt)
This class executes the shell command logcat and parses the output.

package com.example.logviewer

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.BufferedReader
import java.io.InputStreamReader

object LogReader {

    // Regex to parse standard "threadtime" log format
    // Example: 12-01 15:20:01.123 1000 1000 I TagName: Message here
    private val LOG_PATTERN = Regex("""(\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\.\d{3})\s+(\d+)\s+(\d+)\s+([A-Z])\s+([^:]+):\s+(.*)""")

    suspend fun readLogs(): List<LogEntry> {
        return withContext(Dispatchers.IO) {
            val logs = mutableListOf<LogEntry>()
            try {
                // -d dumps the log and exits (non-blocking)
                // -v threadtime gives us the timestamp format we want
                val process = Runtime.getRuntime().exec("logcat -d -v threadtime")
                val reader = BufferedReader(InputStreamReader(process.inputStream))

                var line: String?
                var idCounter = 0
                
                while (reader.readLine().also { line = it } != null) {
                    line?.let { rawLine ->
                        val match = LOG_PATTERN.find(rawLine)
                        if (match != null) {
                            val (time, pid, tid, level, tag, msg) = match.destructured
                            logs.add(
                                LogEntry(
                                    id = idCounter++,
                                    timestamp = time,
                                    level = level,
                                    tag = tag.trim(),
                                    message = msg
                                )
                            )
                        }
                    }
                }
                reader.close()
            } catch (e: Exception) {
                logs.add(LogEntry(0, "", "E", "APP_ERROR", "Failed to read logs: ${e.message}"))
            }
            // Return reversed so newest logs are at the top
            logs.reversed()
        }
    }
}

4. The ViewModel (MainViewModel.kt)
Handles the state and business logic.

package com.example.logviewer

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MainViewModel : ViewModel() {

    private val _logs = MutableStateFlow<List<LogEntry>>(emptyList())
    val logs: StateFlow<List<LogEntry>> = _logs

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private val _permissionGranted = MutableStateFlow(true)
    val permissionGranted: StateFlow<Boolean> = _permissionGranted

    init {
        loadLogs()
    }

    fun loadLogs() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                // Simple check to see if we can run logcat
                // If the list is empty or throws security exception, we handle it
                val result = LogReader.readLogs()
                if (result.isEmpty()) {
                     // In a real app, you might want a more robust permission check
                     // utilizing PackageManager, but checking the output is effective for logcat
                }
                _logs.value = result
            } catch (e: SecurityException) {
                _permissionGranted.value = false
            } catch (e: Exception) {
                // Generic error handling
            } finally {
                _isLoading.value = false
            }
        }
    }
}

5. The UI (MainActivity.kt)
A simple Compose UI to display the list.

package com.example.logviewer

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.viewModels
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.logviewer.ui.theme.LogViewerTheme

class MainActivity : ComponentActivity() {
    private val viewModel by viewModels<MainViewModel>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            LogViewerTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
                    LogScreen(viewModel)
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LogScreen(viewModel: MainViewModel) {
    val logs by viewModel.logs.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("System Event Logs") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primary
                ),
                actions = {
                    Button(onClick = { viewModel.loadLogs() }) {
                        Text("Refresh")
                    }
                }
            )
        }
    ) { innerPadding ->
        Box(modifier = Modifier.padding(innerPadding)) {
            if (logs.isEmpty() && !isLoading) {
                 PermissionInstruction()
            } else {
                LogList(logs)
            }
            
            if (isLoading) {
                CircularProgressIndicator(modifier = Modifier.fillMaxSize().wrapContentSize())
            }
        }
    }
}

@Composable
fun LogList(logs: List<LogEntry>) {
    LazyColumn(modifier = Modifier.fillMaxSize().padding(8.dp)) {
        items(logs) { log ->
            LogItem(log)
            Divider(color = Color.LightGray, thickness = 0.5.dp)
        }
    }
}

@Composable
fun LogItem(log: LogEntry) {
    Row(modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {
        // Log Level Indicator
        Box(
            modifier = Modifier
                .width(4.dp)
                .height(40.dp)
                .background(log.getLevelColor())
        )
        
        Spacer(modifier = Modifier.width(8.dp))
        
        Column {
            Row {
                Text(
                    text = log.timestamp,
                    style = MaterialTheme.typography.bodySmall,
                    color = Color.Gray,
                    fontSize = 10.sp
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = log.level,
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold,
                    color = log.getLevelColor()
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = log.tag,
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold
                )
            }
            Text(
                text = log.message,
                style = MaterialTheme.typography.bodyMedium,
                fontFamily = FontFamily.Monospace,
                maxLines = 10
            )
        }
    }
}

@Composable
fun PermissionInstruction() {
    Column(modifier = Modifier.padding(16.dp)) {
        Text("No Logs Found / Permission Denied", style = MaterialTheme.typography.headlineSmall)
        Spacer(modifier = Modifier.height(16.dp))
        Text("Android blocks reading system logs by default.")
        Text("To enable this app, run this command on your computer:")
        Spacer(modifier = Modifier.height(8.dp))
        Card(colors = CardDefaults.cardColors(containerColor = Color.LightGray)) {
            Text(
                text = "adb shell pm grant com.example.logviewer android.permission.READ_LOGS",
                modifier = Modifier.padding(16.dp),
                fontFamily = FontFamily.Monospace
            )
        }
        Spacer(modifier = Modifier.height(8.dp))
        Text("Then press Refresh.")
    }
}

How to Run This
Since standard permissions won't work, you must follow these steps after compiling and installing the app on your phone:

Connect your phone to your PC via USB.
Open your terminal/command prompt.
Run the following ADB command (replace com.example.logviewer with your actual package name):

adb shell pm grant com.example.logviewer android.permission.READ_LOGS

Open the app and click Refresh.

Key Features of This Code
Safety: It uses logcat -d (dump) rather than streaming, preventing the app from freezing the UI thread while waiting for logs.
Regex Parsing: Converts raw text into a structured Kotlin object.
Visuals: Color-codes the logs (Red for Error, Blue for Debug, etc.) for better readability.
Error Handling: Provides a UI instruction card if the logs are empty (likely due to missing permissions).
Would you like me to add a filter bar so you can search for specific tags or keywords within the logs?

Affirmative

Here is the updated code incorporating a real-time search filter.
This implementation uses the MVVM pattern to filter the logs efficiently. We will update the MainViewModel to handle the filtering logic so the UI remains responsive, and update the MainActivity to include the search bar.
1. Update: MainViewModel.kt
We will add a searchQuery state and a new flow called filteredLogs. This flow automatically combines the raw logs and the search query. Whenever either changes, the list updates immediately.

package com.example.logviewer

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class MainViewModel : ViewModel() {

    // The raw source of truth from the system
    private val _logs = MutableStateFlow<List<LogEntry>>(emptyList())

    // The current text in the search bar
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    // Derived state: Automatically updates when _logs OR _searchQuery changes
    val filteredLogs: StateFlow<List<LogEntry>> = _logs.combine(_searchQuery) { logs, query ->
        if (query.isBlank()) {
            logs
        } else {
            logs.filter {
                it.tag.contains(query, ignoreCase = true) ||
                it.message.contains(query, ignoreCase = true) ||
                it.level.equals(query, ignoreCase = true)
            }
        }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = emptyList()
    )

    init {
        loadLogs()
    }

    fun onSearchQueryChanged(query: String) {
        _searchQuery.value = query
    }

    fun loadLogs() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                val result = LogReader.readLogs()
                _logs.value = result
            } catch (e: Exception) {
                // Handle errors
            } finally {
                _isLoading.value = false
            }
        }
    }
}

2. Update: MainActivity.kt
We need to add the SearchBar composable and update LogScreen to observe filteredLogs instead of the raw logs.

package com.example.logviewer

// ... imports remain the same, ensure you have these:
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
// ...

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LogScreen(viewModel: MainViewModel) {
    // Observe the FILTERED logs, not the raw ones
    val logs by viewModel.filteredLogs.collectAsState()
    val query by viewModel.searchQuery.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    Scaffold(
        topBar = {
            Column {
                TopAppBar(
                    title = { Text("System Event Logs") },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.primaryContainer,
                        titleContentColor = MaterialTheme.colorScheme.primary
                    ),
                    actions = {
                        Button(onClick = { viewModel.loadLogs() }) {
                            Text("Refresh")
                        }
                    }
                )
                // Search Bar placed directly under the TopAppBar
                SearchBar(
                    query = query,
                    onQueryChanged = { viewModel.onSearchQueryChanged(it) }
                )
            }
        }
    ) { innerPadding ->
        Box(modifier = Modifier.padding(innerPadding)) {
            // Show instructions if raw logs are empty (permission issue), 
            // but if we just have no search results, show "No results found"
            if (logs.isEmpty() && !isLoading) {
                if (query.isNotEmpty()) {
                    Box(modifier = Modifier.fillMaxSize(), contentAlignment = androidx.compose.ui.Alignment.Center) {
                        Text("No logs match your search.")
                    }
                } else {
                    PermissionInstruction()
                }
            } else {
                LogList(logs)
            }

            if (isLoading) {
                CircularProgressIndicator(modifier = Modifier.align(androidx.compose.ui.Alignment.Center))
            }
        }
    }
}

@Composable
fun SearchBar(query: String, onQueryChanged: (String) -> Unit) {
    TextField(
        value = query,
        onValueChange = onQueryChanged,
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp),
        placeholder = { Text("Filter by Tag, Message, or Level...") },
        leadingIcon = { Icon(Icons.Default.Search, contentDescription = "Search") },
        trailingIcon = {
            if (query.isNotEmpty()) {
                IconButton(onClick = { onQueryChanged("") }) {
                    Icon(Icons.Default.Close, contentDescription = "Clear")
                }
            }
        },
        singleLine = true,
        colors = TextFieldDefaults.colors(
            focusedIndicatorColor = Color.Transparent,
            unfocusedIndicatorColor = Color.Transparent
        ),
        shape = MaterialTheme.shapes.medium
    )
}

// ... LogList, LogItem, and PermissionInstruction remain the same as previous step

Summary of Changes
Reactive Filtering: We used combine in the ViewModel. This is efficient because it runs on a background thread (via Coroutines) and only re-calculates when the user types or the logs refresh.
Case Insensitive: The filter ignores capitalization, so searching "error" finds "ERROR" tags.
UI Feedback: Added a "Clear" (X) button in the search bar for better user experience.
